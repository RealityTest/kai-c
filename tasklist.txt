CONTRIBUTING.md:4:TODO: a list and overview of all the data structures in the project.
src/ast.c:56:FIXME: Better description
src/checker.c:52:TODO: @goto
src/checker.c:415:TODO: Coercion to union
src/checker.c:416:TODO: Coercion from enum
src/checker.c:431:TODO: Implement this properly
src/checker.c:468:TODO: All to Union
src/checker.c:492:TODO: Integer to enum and vica versa
src/checker.c:494:TODO: function to pointer and vica versa
src/checker.c:498:TODO: ConversionKind_Invalid for non developer releases?
src/checker.c:540:TODO: Test this
src/checker.c:615:TODO: Union type
src/checker.c:631:TODO: Enum <-> Integer
src/checker.c:700:TODO: Context switch to the declaration's context
src/checker.c:708:TODO: For cyclic types we need a ctx->hasIndirection to check and see if
src/checker.c:809:TODO: Check if it's possible through casting and add note that you can cast to make the conversion occur @ErrorQuality
src/checker.c:964:FIXME: We need to extract and pass on desired types parameters & results
src/checker.c:981:TODO: Support unnamed parameters ($0, $1, $2)
src/checker.c:1068:TODO: Should we support non constants?
src/checker.c:1145:TODO: We want to make &Foo{} possible, does that mean we should make this addressable
src/checker.c:1157:TODO: Should we be doing desired type things for types themselves?
src/checker.c:1286:TODO: Check for duplicate names!
src/checker.c:1287:TODO: Check the max alignment of the Target Arch and cap alignment requirements to that
src/checker.c:1367:TODO: clean this up
src/checker.c:1478:TODO: @Strings @Builtins
src/checker.c:1480:TODO: @Structs @Builtins
src/checker.c:1482:TODO: @Strings
src/checker.c:1634:TODO: Constant evaluation for struct types.
src/checker.c:1659:TODO: For cyclic types we need a ctx->hasIndirection to check and see if
src/checker.c:1722:TODO: check args keys match
src/checker.c:1746:TODO: Implement checking for calls
src/checker.c:1948:TODO: Simplify the above ... possibly by shifting around the ExprMode orders so that Addressable is lesser then Value.
src/checker.c:2001:FIXME: figure out how to recover from a duplicate
src/checker.c:2056:TODO: Use the language value comes from the %zu (st|nd|rd|th) result of the call to %s
src/checker.c:2149:TODO: Path stuff
src/checker.c:2226:TODO: Use the language value comes from the %zu (st|nd|rd|th) result of the call to %s
src/checker.c:2269:FIXME: Because we use desiredType, we can't return from things like loop bodies? ...
src/checker.c:2273:FIXME: What about returns that are tuples? We need a nice splat helper
src/checker.c:2294:TODO: Determine if we actually want to enable this sort of behaviour
src/checker.c:2415:FIXME: Why are we doing this, won't it mean we can't infer type of returns in loop bodies?
src/checker.c:2449:FIXME: Why are we doing this, won't it mean we can't infer type of returns in loop bodies?
src/checker.c:2737:TODO: Implicitly sized array's should error without context.
src/checker.c:3078:TODO: Implicitely sized array's should be the size of their maxIndex (not just the number of elements)
src/checker.c:3176:TODO: Need to implement array types
src/checker.c:3202:TODO: Goto & fallthrough
src/error.c:249:TODO: Static & Thread Local?
src/types.c:36:TODO: Mechanism to lookup type by their ID
src/types.c:91:FIXME: This doesn't sign extend to the target size currently, only 64 bits.
src/types.c:152:TODO: @CircularTypes
src/types.c:204:FIXME: Error for oversized arrays
src/types.c:399:TODO: Do we need an UntypedUintType? ... UntypedIntType cannot represent values over INT64_MAX;
src/types.c:439:TODO: Something about aliased type names ie. 'rawptr' aka '*u8'
src/llvm.cpp:120:TODO: Should they?
src/llvm.cpp:171:TODO: Kai vargs
src/llvm.cpp:180:TODO: When we support importing symbols into other scopes we will need to do a context switch
src/llvm.cpp:280:TODO: LineNo for struct members
src/llvm.cpp:434:FIXME: Is there some cleaner way to achieve this? This is probably one of the worst ways to do this.
src/llvm.cpp:452:TODO: Add initializer to some sort of premain?
src/llvm.cpp:515:TODO: Implement conversion to Any type
src/llvm.cpp:533:TODO: Switch to the symbol's package (only relevant when a symbol can be imported) into another scope
src/llvm.cpp:565:TODO: We need to work out how to apply calling conventions across the board for functions!
src/llvm.cpp:591:FIXME: Determine if, like C, all uninitialized Struct members are zero'd or left undefined
src/llvm.cpp:615:FIXME: Determine if, like C all uninitialized Array members are zero'd or left undefined
src/llvm.cpp:741:TODO: @Strings
src/llvm.cpp:830:FIXME: 
src/llvm.cpp:995:TODO: Set calling convention
src/llvm.cpp:1005:TODO: Set isOptimized in a logical way
src/llvm.cpp:1006:TODO: Set isLocalToUnit (if a function is declared in a function scope)
src/llvm.cpp:1035:TODO: Support unnamed parameters ($0, $1, $2)
src/llvm.cpp:1064:FIXME: In order to support nested functions we must restore retBlock, deferStack, retValue ...
src/llvm.cpp:1120:FIXME: Return to previous scope
src/llvm.cpp:1239:TODO: CreateLifetimeStart for this symbol (if applicable)
src/llvm.cpp:1252:FIXME: We need to start using external name correctly, it should be always set
src/llvm.cpp:1255:FIXME: we need to set the debug info subprogram's actual name. Right now it will be set to the mangled name.
src/llvm.cpp:1292:TODO: CreateLifetimeStart for this symbol
src/llvm.cpp:1326:FIXME: Globals are not handled here at all
src/llvm.cpp:1657:TODO: Boolean-esque switch
src/llvm.cpp:1672:TODO: number cases
src/llvm.cpp:1701:TODO: unions and any support
src/llvm.cpp:1827:TODO: Initialize only for the targets we are outputting.
src/llvm.cpp:1863:TODO: Only on unoptimized builds
src/llvm.cpp:1868:TODO: Handle targets correctly by using TargetOs & TargetArch globals
src/llvm.cpp:1876:TODO: Include details about the kai compiler version in the module metadata. clang has the following:
src/llvm.cpp:1888:TODO: Set isOptimized in a logical way
src/llvm.cpp:1889:TODO: Set RuntimeVersion in some logical way
src/llvm.cpp:1916:TODO: Figure out where and how we want to handle these
src/llvm.cpp:2004:TODO: linking on Windows and Linux
src/ast.h:50:TODO: This needs to include some more directives (for example static asserts `#assert` should be supported at top level)
src/ast.h:501:TODO: All decls should have space for a calling convention
src/lexer.c:270:TODO: @performance use StrInternRange
src/map.c:14:FIXME: When 2 hashes are the same, they cancel out
src/flags.c:152:TODO: should we use the basename of InputName?
src/os.c:14:FIXME: We are mmap()'ing this with no way to munmap it currently
src/os.c:19:FIXME: No matching close
src/parser.c:914:FIXME: Make a Stmt_IdentList
src/parser.c:920:FIXME: What is going on here?
src/parser.c:1098:TODO: Some sort of scratch allocator on the package?
src/parser.c:1124:FIXME: @position If there is no suffix directive then the end used from this is the start of the next token
src/parser.c:1179:FIXME: Get the range for the directive
src/parser.c:1189:FIXME: Allow only @newlines_only
src/parser.c:1200:FIXME: Position should be the linkPrefix position
src/parser.c:1383:TODO: To properly support out of order declarations things we will need to re-evaluate how we
